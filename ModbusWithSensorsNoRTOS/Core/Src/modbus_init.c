/**
 * @file    modbus_init.c
 * @brief   Modbus initialization and processing
 * @author  Generated by Copilot
 */

#include "modbus_init.h"
#include "main.h"
#include "modbus_device.h"
#include "mbutils.h"

/* Private variables ---------------------------------------------------------*/
extern UART_HandleTypeDef huart1;
static mbus_t modbus_context;
static Modbus_Conf_t modbus_config;
uint8_t modbus_rx_buffer[256];
uint8_t modbus_tx_buffer[256];

/* Private function prototypes -----------------------------------------------*/
static int Modbus_SendData(const mbus_t context, const uint8_t *data, const uint16_t size);

/* Exported functions -------------------------------------------------------*/

/**
 * @brief  Initialize Modbus RTU slave
 * @param  None
 * @retval None
 */
void Modbus_Init(void)
{
    // printf("Initializing Modbus...\n"); // Removed to prevent timing delays

    // Configure Modbus
    modbus_config.devaddr = 0x01; // Slave address
    modbus_config.coils = 0;      // No internal coil handling
    modbus_config.discrete = 0;   // No internal discrete handling
    modbus_config.device = NULL;  // No device pointer needed
    modbus_config.send = Modbus_SendData;
    modbus_config.read = Modbus_Device_Read;
    modbus_config.write = Modbus_Device_Write;
    modbus_config.sendbuf = modbus_tx_buffer;
    modbus_config.sendbuf_sz = sizeof(modbus_tx_buffer);
    modbus_config.recvbuf = modbus_rx_buffer;
    modbus_config.recvbuf_sz = sizeof(modbus_rx_buffer);

    // printf("Modbus config: addr=0x%02X, buffers=%d/%d bytes\n",
    //        modbus_config.devaddr, modbus_config.sendbuf_sz, modbus_config.recvbuf_sz); // Removed

    // Initialize Modbus context
    modbus_context = mbus_open(&modbus_config);
    // printf("Modbus context opened: %d\n", modbus_context); // Removed

    // Set register values AFTER mbus_open (like sample code does)
    device_registers[0] = 20;  // 40001
    device_registers[1] = 19;  // 40002
    device_registers[2] = 18;  // 40003
    device_registers[3] = 17;  // 40004
    device_registers[4] = 16;  // 40005
    device_registers[5] = 15;  // 40006
    device_registers[6] = 14;  // 40007
    device_registers[7] = 13;  // 40008
    device_registers[8] = 12;  // 40009
    device_registers[9] = 11;  // 40010
    device_registers[10] = 10; // 40011
    device_registers[11] = 9;  // 40012
    device_registers[12] = 8;  // 40013
    device_registers[13] = 7;  // 40014
    device_registers[14] = 6;  // 40015
    device_registers[15] = 5;  // 40016
    device_registers[16] = 4;  // 40017
    device_registers[17] = 3;  // 40018
    device_registers[18] = 2;  // 40019
    device_registers[19] = 1;  // 40020

    // Debug: Verify register values (only at startup, before Modbus communication starts)
    // printf("Register verification after initialization:\n"); // Removed to prevent timeouts
    // for (int i = 0; i < 20; i++)
    // {
    //     printf("Reg[%d] = %d\n", i, device_registers[i]);
    // }
    // printf("Registers initialized. Ready for ModbusPoll connection.\n"); // Removed to prevent timeouts

    // Start UART DMA reception
    HAL_UARTEx_ReceiveToIdle_DMA(&huart1, modbus_rx_buffer, sizeof(modbus_rx_buffer));
    // printf("DMA reception started: %d\n", dma_status); // Removed

    // Enable UART idle line interrupt for Modbus frame detection
    __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
    // printf("UART idle interrupt enabled\n"); // Removed
}

/**
 * @brief  Process Modbus communication
 * @param  None
 * @retval None
 */
void Modbus_Process(void)
{
    // This function can be called in main loop if needed
    // Currently, processing is handled in UART callback
}

/* Private functions -------------------------------------------------------*/

/**
 * @brief  Modbus send function
 * @param  context: Modbus context
 * @param  data: Data to send
 * @param  size: Size of data
 * @retval Number of bytes sent
 */
static int Modbus_SendData(const mbus_t context, const uint8_t *data, const uint16_t size)
{
    // Debug: Toggle PA4 to indicate transmission start
    // HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_4); // Commented out to eliminate timing delays

    // printf("Modbus TX: Sending %d bytes\n", size); // Commented out to prevent timeouts
    // for (uint16_t i = 0; i < size; i++)
    // {
    //     printf("0x%02X ", data[i]);
    // }
    // printf("\n");

    HAL_StatusTypeDef status = HAL_UART_Transmit(&huart1, (uint8_t *)data, size, 1000);

    if (status == HAL_OK)
    {
        // printf("TX Success\n"); // Removed to prevent timing delays
        return size;
    }
    else
    {
        // printf("TX Failed: %d\n", status); // Removed to prevent timing delays
        return 0;
    }
}

/**
 * @brief  Get Modbus context (for external access)
 * @param  None
 * @retval Modbus context
 */
mbus_t Modbus_GetContext(void)
{
    return modbus_context;
}