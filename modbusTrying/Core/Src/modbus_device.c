/**
 * @file    modbus_device.c
 * @brief   Modbus device-specific read/write functions
 * @author  Generated by Copilot
 */

#include "modbus_device.h"
#include <stdio.h>

/* Private variables ---------------------------------------------------------*/
// Device registers (Holding Registers - 4xxxx) - Made global like sample code
uint16_t device_registers[20] = {
    1,  // 40001: Register 0
    2,  // 40002: Register 1
    3,  // 40003: Register 2
    4,  // 40004: Register 3
    5,  // 40005: Register 4
    6,  // 40006: Register 5
    7,  // 40007: Register 6
    8,  // 40008: Register 7
    9,  // 40009: Register 8
    10, // 40010: Register 9
    11, // 40011: Register 10
    12, // 40012: Register 11
    13, // 40013: Register 12
    14, // 40014: Register 13
    15, // 40015: Register 14
    16, // 40016: Register 15
    17, // 40017: Register 16
    18, // 40018: Register 17
    19, // 40019: Register 18
    20  // 40020: Register 19
};

// Debug: Verify array initialization
void Modbus_Device_DebugArray(void)
{
    printf("Device Registers Array Contents:\n");
    for (int i = 0; i < 20; i++)
    {
        printf("  [%d] 0x%04X (%d)\n", i, device_registers[i], device_registers[i]);
    }
}

/* Private function prototypes -----------------------------------------------*/

/* Exported functions -------------------------------------------------------*/

/**
 * @brief  Get register value by index
 * @param  index: Register index (0-19)
 * @retval Register value
 */
uint16_t Modbus_Device_GetRegister(uint8_t index)
{
    if (index < 20)
    {
        return device_registers[index];
    }
    return 0;
}

/**
 * @brief  Modbus device read callback
 * @param  logical_address: Modbus logical address (40001, 40002, etc.)
 * @retval Register value
 */
uint16_t Modbus_Device_Read(uint32_t logical_address)
{
    // Simple direct array access like the sample code
    if (logical_address >= 40001 && logical_address <= 40020)
    {
        uint16_t index = logical_address - 40001;
        uint16_t value = device_registers[index];

        // Minimal debug: only for first few registers to avoid timing issues
        if (index < 6) {
            printf("READ: addr=%lu, index=%d, returning %d\n", logical_address, index, value);
        }

        return value;
    }

    return 0; // Invalid address
}

/**
 * @brief  Modbus device write callback
 * @param  logical_address: Modbus logical address (40001, 40002, etc.)
 * @param  value: Value to write
 * @retval Written value
 */
uint16_t Modbus_Device_Write(uint32_t logical_address, uint16_t value)
{
    // Convert logical address to array index
    if (logical_address >= 40001 && logical_address <= 40020)
    {
        uint16_t index = logical_address - 40001;

        // Handle special write operations
        switch (logical_address)
        {
        case 40015: // Configuration register 1
            // Apply_Configuration1(value);
            break;

        case 40016: // Configuration register 2
            // Apply_Configuration2(value);
            break;

        case 40017: // Calibration value 1
            // Set_Calibration1(value);
            break;

        case 40018: // Calibration value 2
            // Set_Calibration2(value);
            break;

        case 40019: // Test register - can be written for testing
            // Handle test operations
            break;

        default:
            // Store value for other registers
            break;
        }

        // Store the value
        device_registers[index] = value;
        return value;
    }

    return 0; // Invalid address
}

/**
 * @brief  Update sensor values (call this periodically)
 * @param  None
 * @retval None
 */
void Modbus_Device_UpdateSensors(void)
{
    // Update sensor values - call this from main loop or timer
    // device_registers[0] = Read_Sensor1_Value();  // 40001
    // device_registers[1] = Read_Sensor2_Value();  // 40002
    // device_registers[4] = Read_Temperature();    // 40005
    // device_registers[5] = Read_Humidity();       // 40006
    // etc.
}

/**
 * @brief  Set device register value (for internal use)
 * @param  index: Register index (0-19 for 40001-40020)
 * @param  value: Value to set
 * @retval None
 */
void Modbus_Device_SetRegister(uint8_t index, uint16_t value)
{
    if (index < 20)
    {
        device_registers[index] = value;
    }
}