/**
 * @file    modbus_device.c
 * @brief   Modbus device-specific read/write functions
 * @author  Generated by Copilot
 */

#include "modbus_device.h"

/* Private variables ---------------------------------------------------------*/
// Device registers (Holding Registers - 4xxxx) - Made global like sample code
uint16_t device_registers[20] = {
    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
    10, 9, 8, 7, 6, 5, 4, 3, 2, 1};

/* Private function prototypes -----------------------------------------------*/

/* Exported functions -------------------------------------------------------*/

/**
 * @brief  Get register value by index
 * @param  index: Register index (0-19)
 * @retval Register value
 */
uint16_t Modbus_Device_GetRegister(uint8_t index)
{
    if (index < 20)
    {
        return device_registers[index];
    }
    return 0;
}

/**
 * @brief  Modbus device read callback
 * @param  logical_address: Modbus logical address (40001, 40002, etc.)
 * @retval Register value
 */
uint16_t Modbus_Device_Read(uint32_t logical_address)
{
    // Simple direct array access like the sample code
    if (logical_address >= 40001 && logical_address <= 40020)
    {
        uint16_t index = logical_address - 40001;
        uint16_t value = device_registers[index];

        // Debug: Show what we're returning for ALL registers
        // printf("READ: addr=%lu, index=%d, returning %d (0x%04X)\n", logical_address, index, value, value); // Removed to prevent timeouts

        return value;
    }

    return 0; // Invalid address
}

/**
 * @brief  Modbus device write callback
 * @param  logical_address: Modbus logical address (40001, 40002, etc.)
 * @param  value: Value to write
 * @retval Written value
 */
uint16_t Modbus_Device_Write(uint32_t logical_address, uint16_t value)
{
    // Convert logical address to array index
    if (logical_address >= 40001 && logical_address <= 40020)
    {
        uint16_t index = logical_address - 40001;

        // Handle special write operations
        switch (logical_address)
        {
        case 40015: // Configuration register 1
            // Apply_Configuration1(value);
            break;

        case 40016: // Configuration register 2
            // Apply_Configuration2(value);
            break;

        case 40017: // Calibration value 1
            // Set_Calibration1(value);
            break;

        case 40018: // Calibration value 2
            // Set_Calibration2(value);
            break;

        case 40019: // Test register - can be written for testing
            // Handle test operations
            break;

        default:
            // Store value for other registers
            break;
        }

        // Store the value
        device_registers[index] = value;
        return value;
    }

    return 0; // Invalid address
}

/**
 * @brief  Update sensor values (call this periodically)
 * @param  None
 * @retval None
 */
void Modbus_Device_UpdateSensors(void)
{
    // Update sensor values - call this from main loop or timer
    // device_registers[0] = Read_Sensor1_Value();  // 40001
    // device_registers[1] = Read_Sensor2_Value();  // 40002
    // device_registers[4] = Read_Temperature();    // 40005
    // device_registers[5] = Read_Humidity();       // 40006
    // etc.
}

/**
 * @brief  Set device register value (for internal use)
 * @param  index: Register index (0-19 for 40001-40020)
 * @param  value: Value to set
 * @retval None
 */
void Modbus_Device_SetRegister(uint8_t index, uint16_t value)
{
    if (index < 20)
    {
        device_registers[index] = value;
    }
}